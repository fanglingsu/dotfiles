#!/usr/bin/env bash
# Setup a magento project to a defined state.
#
# Configuration is read from .config.sh of the
# directory where the script is called from.

# use the directory from where the script is called
CONFIG_FILE=".config.sh"
BASE_DIR="$(readlink -fn -- `pwd`)"

# include some nice messaging functions
source functions.sh

if [ ! -f "$BASE_DIR/$CONFIG_FILE" ]; then
    write_error "No $CONFIG_FILE found in $BASE_DIR"
    exit 1
fi

source "$BASE_DIR/$CONFIG_FILE"

# check if the required configs are available
if [ "$MAGENTO_DIR" = "" ]; then
    write_error "No magento directory defined"
    exit 1
fi

# set some default config if it was not found in config file
PROJECT_DIR=${PROJECT_DIR:-$BASE_DIR}
BASE_URL=${BASE_URL:-"http://localhost"}
# trim trailing slash from base url
BASE_URL=${BASE_URL%/}
SQL_DUMP=${SQL_DUMP:-"master-db.sql"}
DB_NAME=${DB_NAME:-"default"}
DB_TABLE_PREFIX=${DB_TABLE_PREFIX:-""}
if [ "$DB_USER" != "" ]; then
    DB_CREDENTIALS="-u$DB_USER -p$DB_PASS"
else
    DB_CREDENTIALS=""
fi

source mage-base.sh

# show current config
show_config() {
    message_head "Show Config"
    cat >&2 << EOM
    PROJECT_DIR:    $PROJECT_DIR
    MAGENTO_DIR:    $MAGENTO_DIR
    BASE_URL:       $BASE_URL
    SQL_DUMP:       $SQL_DUMP
    DB_NAME:        $DB_NAME
    DB_TABLE_PREFIX $DB_TABLE_PREFIX
EOM
}

show_help() {
    cat >&2 << EOM
USAGE:   $(basename $0) [OPTIONS]

OPTIONS:
   -b            Make symlinks from project to Magento. Paths to be linked are read
                 from .links file which can be create by $(basename $0) -P > .links
   -B            Remove all symlinks into Magento
   -c            Cleanup Caches
   -C [OPTION]   List or Run Cronjobs
                 'list' to show defined Cronjobs
                 {job_name} to run the given Cronjob
   -d            Cleanup Database
   -D            Dump Database
   -g            Get dumped data to product given by ID
   -h            Show this help
   -i            Initialize Magento by call to BASE_URL
   -I            Initialize Magento by call to wsdl URL
   -l            Cleanup logs
   -m [OPTION]   Set Magento value lowercase char for off uppercase for on
                 'c' enable/disable Caching
                 'h' enable/disable Template Hints
   -n            Ring the bell - could be used as laast action to
                 signalize that the job is done
   -p            Run PHP-CopyPast-Detector
   -P            Print out the paths for modman file from build.xml
   -r            Reindex all Magento Indexes
   -s            Run PHP-CodeSniffer
   -t            Run PHPUnit-Tests
   -T            Print PHPUnit-XML to stdout
   -x            Show some Configration Variables

CONFIGURATION: $CONFIG_FILE in directory where this script is called from.
   PROJECT_DIR        Directory with the project sources
   MAGENTO_DIR        Directory width the clean magento source
   BASE_URL           URL to the magento start page to trigger upgrades or something else useful
   SQL_DUMP           Name of the Database dump in PROJECT_DIR
   DB_USER            Database User
   DB_PASS            Database Password
   DB_NAME            Database Name
   DB_TABLE_PREFIX    Table Prefix used for the Tables
EOM
}

# remove a file and print the success message
rmfile() {
    local path="$1"
    rm -rf "$path"
    if [ $? -eq 0 ]; then
        write_success "$path"
    else
        write_error "$path"
    fi
}

run_db_command() {
    local command=$1
    if [ "$command" = "" ]; then
        write_error "No query given"
        return 1
    fi

    $(mysql ${DB_CREDENTIALS} -s -e "$command" > /dev/null 2>&1)
    echo "$?"
}

clean_cache() {
    local path
    local backend
    local dbnum
    local caches=("cache" "full_page_cache")

    message_head "Clear Caches"

    for xpath in "${caches[@]}"; do
        backend=$(xml sel -t -m "//global/$xpath/backend" -v "text()" -n ${MAGENTO_DIR}/app/etc/local.xml)
        # longest substring match - keep everithings after last _
        backend=${backend##*_}
        backend=${backend:-"File"}

        case "$backend" in
            [Rr]edis )
                # get the database number used for caches
                dbnum=$(xml sel -t -m "//global/$xpath/backend_options/database" -v "text()" -n ${MAGENTO_DIR}/app/etc/local.xml)
                if [ "$dbnum" != "" ]; then
					action "$backend $xpath" redis-cli -n $dbnum FLUSHDB &> /dev/null
                fi
                ;;

            [Ff]ile )
                if [ -d "$MAGENTO_DIR/var/$xpath" ]; then
					action "$backend $xpath" rm -rf $MAGENTO_DIR/var/$xpath/mage--*
                fi
                ;;
        esac
    done

    action "Zend cache" rm -rf /tmp/zend_cache---*
    action "PHPUnit cache" rm -rf /tmp/phpunit
}

clean_logs() {
    local path

    message_head "Remove Logs"
    for path in `find ${MAGENTO_DIR}/var/log/ -type f -name *.log`; do
        rmfile "$path"
    done
}

drop_db() {
    local command="drop database $DB_NAME;"

    return $(run_db_command "$command")
}

create_db() {
    local command="create database $DB_NAME default char set utf8;"

    return $(run_db_command "$command")
}

import_dump() {
    local dump=$1
    local command="use $DB_NAME;source $dump;"

    return $(run_db_command "$command")
}

create_phpunit_xml() {
    cd $MAGENTO_DIR
    cat << EOM
<phpunit
    bootstrap="Bootstrap.php"
    syntaxCheck="true"
    verbose="true"
    strict="false"
    colors="false"
    debug="false"
    stopOnFailure="false"
    processIsolation="false"
    backupGlobal="false">

    <testsuite name="default">
EOM

    if [ -d tests ]; then
        local path=''
        for i in $(find -L tests -name '*Test.php' -a \! -name 'config.php' -a \! -name 'functions.php' -a \! -name 'Bootstrap.php')
        do
            path=$(readlink -f "$i")
            echo "        <file>$path</file>"
        done
    fi

    cat << EOM
    </testsuite>
</phpunit>
EOM
}

run_phpunit() {
    cd $MAGENTO_DIR
    local config=$(mktemp -p tests -t 'test-XXX.xml' -u)

    create_phpunit_xml > "$config"

    # run phpunit with the temporary config
    php -c /etc/php/performance.ini /usr/bin/phpunit.phar -c "$config" tests/

    # remove no more used config
    rm "$config"
}

run_phpcs() {
    cd $PROJECT_DIR
    phpcs --standard=ZEND --extensions=php -p -n app/code/local tests
}

run_phpcpd() {
    cd $PROJECT_DIR
    phpcpd app/code/local tests
}

clean_db() {
    local dump="${PROJECT_DIR}/${SQL_DUMP}"
    message_head "Cleanup Database"
    # don't remove database if the dump file does not exist
    if [ ! -f "$dump" ]; then
        write_error "Dump file $dump does not exist"
        return 1
    fi

    action "DROP Database" drop_db
    action "Create Database" create_db
    action "Import Dump" import_dump "$dump"
}

dump_db() {
    message_head "Create Database Dump"
    local path="${PROJECT_DIR}/${SQL_DUMP}"

    # dump the database
    $(mysqldump $DB_CREDENTIALS "$DB_NAME" > "$path")

    if [ $? -eq 0 ]; then
        write_success "Dumped Database into $path"
    else
        write_error "Could not dump Database"
    fi
}

dump_product() {
    local id="$1"
    message_head "Product Data #$id"
    local code=$(cat <<'END_HEREDOC'
Mage::setIsDeveloperMode(true);
umask(0);
Mage::app('admin');
function dump($id) {
    $product = Mage::getModel('catalog/product')->load($id);
    echo json_encode(array_filter($product->getData()), JSON_PRETTY_PRINT);
}
END_HEREDOC
)
    code=$(echo -e "$code\n" "dump($id);")
    code=$(echo -e "require_once '${MAGENTO_DIR}/app/Mage.php';\n$code")

    # run the php code
    php -r "$code"
}

set_magento_value() {
    local opt=$1
    local command

    case "$opt" in
        c)
            echo "Disable Magento Cache:"
            command="use $DB_NAME;\
                UPDATE ${DB_TABLE_PREFIX}core_cache_option\
                SET value=0\
                WHERE value=1;" ;;
        C)
            echo "Enable Magento Cache:"
            command="use $DB_NAME;\
                UPDATE ${DB_TABLE_PREFIX}core_cache_option\
                SET value=1\
                WHERE value=0 AND code != 'full_page';" ;;
        h)
            echo "Disable Template Hints"
            command="use $DB_NAME;\
                DELETE FROM ${DB_TABLE_PREFIX}core_config_data\
                WHERE path='dev/debug/template_hints'\
                    OR path='dev/debug/template_hints_blocks';" ;;
        H)
            echo "Enable Template Hints"
            command="use $DB_NAME;\
                INSERT INTO ${DB_TABLE_PREFIX}core_config_data (scope, scope_id, path, value)\
                SELECT 'websites', w.website_id, 'dev/debug/template_hints', 1 FROM ${DB_TABLE_PREFIX}core_website AS w \
                    WHERE w.code != 'admin' \
                UNION \
                SELECT 'websites', w.website_id, 'dev/debug/template_hints_blocks', 1 FROM ${DB_TABLE_PREFIX}core_website AS w \
                    WHERE w.code != 'admin' \
                ON DUPLICATE KEY UPDATE value=1;" ;;
    esac

    if [ $(run_db_command "$command") -eq 0 ]; then
        write_success "Value set successfully"
    else
        write_error "Value could not be set"
    fi
}

print_build_links() {
    xml sel -t -m "//var[@name='source']" -v "@value" -n ${PROJECT_DIR}/build.xml | \
        sed -e '/^$/d' -e 's@^${source},@@' -e 's/\(.*\)/\1 \1/'
}

relink() {
    message_head "Link Project into Magento"
    if [ ! -f "${PROJECT_DIR}/modman" ]; then
        die "$(write_error 'File modman not found')" 2
    fi

    IFS=$'\r\n'
    for line in $(grep -v '^#\|^\s*$' "$PROJECT_DIR/modman"); do
        IFS=$' \t\n'

        # split <target> <real>
        read target real <<< $line

        # assume target == real if only one path is given
        if [ -z "$real" ]; then
            real="$target"
        fi

        # sanity check for empty data
        if [ -z "$target" -o -z "$real" ]; then
            write_error "Invalid input in modman file: $line"
            return 1
        fi

        # create symlink to target
        local src=$PROJECT_DIR/$target
        local dest=$MAGENTO_DIR/${real%/}
        dest=${dest/\/\//\/}    # replace // with /
        dest=${dest%/}          # strip trailing /

        # handle globbing (extended globbing enabled)
        shopt -s extglob
        if ! [ -e "$src" ] && [ $(ls -l $src 2> /dev/null | wc -l) -gt 0 ]; then
            for _src in $src; do
                apply_path "$_src" "$dest/${_src##*/}" "$target" "${real%/}/${_src##*/}" "$line" || return 1
            done
            continue
        fi

        # handle aliases that do not exist
        if ! [ -e "$src" ]; then
            write_info "Target does not exist: $line"
            continue
        fi

        # allow destination to be a dir when src is a file
        if [ -f "$src" ] && [ -d "$dest" -o "/" = ${real: -1} ]; then
            dest="$dest/$(basename "$src")"
        fi

        apply_path "$src" "$dest" "$target" "$real" "$line" || return 1
    done
}

apply_path() {
    local src="$1"
    local dest="$2"
    local target="$3"
    local real="$4"
    local line="$5"

    # make symlinks relative
    local realpath=$(readlink -m "${dest%/*}")
    local commonpath=""
    if [ "${dest%/*}" == "${realpath}" ]; then
        local mmroot=$(dirname "$PROJECT_DIR")
        # use modman project directory as common path if destination is not
        # itself a symlinked path
        commonpath="${mmroot%/}"
        else
        # search for longest common path as symlink target
        for ((i=0; i<${#dest}; i++)); do
            if [[ "${dest:i:1}" != "${realpath:i:1}" ]]; then
                commonpath="${dest:0:i}"
                commonpath="${commonpath%/*}"
                break
        fi
    done
    fi
    # replace destination (less common path) with ../*
    if [ "$commonpath" != "" ]; then
        local reldest="${dest#$commonpath/}"
        if [ "$reldest" != "${reldest%/*}" ]; then
            reldest=$(IFS=/; for d in ${reldest%/*}; do echo -n '../'; done)
        else
            reldest=""
        fi
        src="${reldest}${src#$commonpath/}"
    fi

    # handle cases where files already exist at the destination or link does
    # not match expected destination
    if [ -e "$dest" ]; then
        if ! [ -L "$dest" ] || [ "$src" != "$(readlink "$dest")" ]; then
            write_info "Removing conflicting $(stat -c %F "$dest"): $dest"
            rm -rf "$dest" || return 1
        fi
    fi

    # create links if they do not already exist
    if ! [ -e "$dest" ]; then
        # delete conflicting symlinks that are broken
        if [ -L "$dest" ]; then
            rm -f "$dest"
        fi
        # create parent directories
        if ! mkdir -p "${dest%/*}"; then
            write_error "Unable to create parent directory (${dest%/*}): $line"
            return 1
        fi
        # create the symlink
        success=0
        ln -s "$src" "$dest" && success=1
        if [ $success -eq 1 ]; then
            write_success "$target\t$real"
        else
            write_error "Unable to create symlink ($dest): $line"
        return 1
        fi
    fi
    return 0
}

unlink() {
    message_head "Remove Links from Magento"

    for path in `find ${MAGENTO_DIR} -type l`; do
        rmfile "$path"
    done
}

# init magento by a request to given url
#
# @param    string url
init_magento() {
    message_head "Initialze Magento"
    local url="$1"

    action "GET $url" wget -q --no-proxy --no-check-certificate -O /dev/null "$url"
}

handle_cronjobs() {
    local opt=$1
    local code=$(cat <<'END_HEREDOC'
Mage::setIsDeveloperMode(true);
umask(0);
Mage::app('admin');
function getCronData() {
    $data = array();
    $jobs = (array)Mage::getConfig()->getNode('crontab/jobs');
    /* @var $job Mage_Core_Model_Config_Element */
    foreach ($jobs as $job) {
        if (!isset($job->schedule->cron_expr) || !($time = (string)$job->schedule->cron_expr)) {
            $time = '-';
        }
        $data[$job->getName()] = $time;
    }
    $jobs = (array)Mage::getStoreConfig('crontab/jobs');
    // put also those cron jobs that are definded under XPath /config/default
    foreach ($jobs as $name => $jobData) {
        $data[$name] = isset($jobData['schedule']['cron_expr']) ? $jobData['schedule']['cron_expr'] : '-';
    }
    ksort($data);
    return $data;
}

function runJobByCode($code) {
    $code = (string)$code;

    // note that we have Mage_Core_Model_Config_Element and array mixed together
    $jobs  = (array)Mage::getConfig()->getNode('crontab/jobs');
    $jobs += (array)Mage::getStoreConfig('crontab/jobs');
    $run   = null;
    if (isset($jobs[$code])
        && ($jobConfig = (array)$jobs[$code])
        && isset($jobConfig['run'])
        && ($runConfig = (array)$jobConfig['run'])
        && isset($runConfig['model'])
        && ($runModel = (string)$runConfig['model'])
    ) {
        if (!preg_match('#^([a-z0-9_]+/[a-z0-9_]+)::([a-z0-9_]+)$#i', $runModel, $run)) {
            throw new RuntimeException('Invalid model/method definition, expecting "model/class::method".');
        }
        if (!($model = Mage::getModel($run[1])) || !method_exists($model, $run[2])) {
            throw new RuntimeException("Invalid callback: {$run[1]}::{$run[2]} does not exist");
        }

        /* @var $schedule Mage_Cron_Model_Schedule */
        $schedule = Mage::getModel('cron/schedule');
        $schedule->setJobCode($code);
        $schedule->setStatus(Mage_Cron_Model_Schedule::STATUS_PENDING);
        $schedule->setCreatedAt(now());
        $schedule->setScheduledAt(now());

        call_user_func_array(array($model, $run[2]), array($schedule));

        return;
    }
    throw new RuntimeException("Cronjob for code {$code} could not be found!");
}

END_HEREDOC
)
    if [ "$opt" == "" ] || [ "$opt" == "list" ]; then
        message_head "List Cronjobs"
        code=$(echo -e "$code\n" '$template = "%-64s\t%-15s\n";')
        code=$(echo -e "$code\n" 'fprintf(STDERR, $template, "Jobcode", "m h dom mon dow");')
        code=$(echo -e "$code\n" 'fprintf(STDERR, $template, str_repeat("-", 64), str_repeat("-", 15));')
        code=$(echo -e "$code\n" 'foreach (getCronData() as $name => $time) {printf($template, $name, $time);}')
    else
        message_head "Run Cronjob $opt"
        code=$(echo -e "$code\n" "runJobByCode('$opt');")
    fi

    php=$(echo -e "require_once '${MAGENTO_DIR}/app/Mage.php';\n$code")

    # run the php code
    php -r "$php"
}

reindex_all() {
    message_head "Reindex Magento Indexes"

    IFS=$'\n'
    for message in `php -f "$MAGENTO_DIR/shell/indexer.php" -- --reindexall`; do
        write_success "$message"
    done
    unset IFS
}

if [ $# -lt 1 ]; then
    die "$(show_help)" 2
fi

# prepare the environment for possible php calls and debugging
export XDEBUG_CONFIG="idekey=PHPSTORM"

while getopts "bBcC:dDg:lm:npPrstThiIx" args; do
    case "$args" in
        b)  relink ;;
        B)  unlink ;;
        c)  clean_cache ;;
        C)  handle_cronjobs $OPTARG ;;
        d)  clean_db ;;
        D)  dump_db ;;
        g)  dump_product $OPTARG ;;
        h)  die "$(show_help)" 2 ;;
        i)  init_magento "$BASE_URL" ;;
        I)  init_magento "$BASE_URL/index.php/api/v2_soap?wsdl=1" ;;
        l)  clean_logs ;;
        m)  set_magento_value $OPTARG ;;
        n)  echo -ne "\a" ;;
        p)  run_phpcpd ;;
        P)  print_build_links ;;
        r)  reindex_all ;;
        s)  run_phpcs ;;
        t)  run_phpunit ;;
        T)  create_phpunit_xml ;;
        x)  show_config ;;
        \?) die "$(show_help)" 2 ;;
    esac
done

# unset previous set environment variables
unset XDEBUG_CONFIG
